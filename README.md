# PROJECT_SETUP
Social Network REST API project setup for Rive Interview

## DEPLOYED API
To save time to you, I deployed the app in heroku.
<ol>
  <li>username: admin@admin.com</li>
  <li>password: riveadmin</li>
  <li> API LINK: https://social-network-rest-api.herokuapp.com/ </li>
</ol>


## LOCAL SET UP
<ol>
  <li>Install python 3.11.1</li>
  <li>Install postgreSQL 15.1</li>
  <li>Install any IDE (visual studio code) in my case</li>
  <li>Create virtual environment: python -m venv venv</li>
  <li>Activate virtual envonment: venv\Scripts\activate.bat</li>
  <li>Install dependencies into venv from requirements.txt: pip install -r requirements.txt</li>
  <li>Create database in PostgreSQL in GUI</li>
  <li>Create ".env" file and set constants (in my case):
        
      DATABASE_HOSTNAME=localhost
      DATABASE_PORT=5432
      DATABASE_PASSWORD=root
      DATABASE_NAME=social_network_db
      DATABASE_USERNAME=postgres
      SECRET_KEY=09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
      ALGORITHM=HS256
      ACCESS_TOKEN_EXPIRE_MINUTES=60
      ADMIN_PWD=riveadmin
  </li>
  <li>Run command to start the app: uvicorn src.main:app (--reload flag to reload when we save)</li>
  <li>Click the link with the app url to access it.</li>
  <li>Once we are in the root page, I setted a create an admin user for authorization purposes. This is not the best way to       do it, but I couldn't find any "post startup" to do it in the cleanest way. </li>
  <li>Read the page, and add /docs to the URL to try de API and read the openAPI documentation.</li>
  <li> Authenticate with username: admin@admin.com and password: riveadmin </li>
</ol>

## API METHODS
All the API methods have type validations since we are using schemas for response and requests.

### users
<ol>
  <li>user_id: private key to identify users</li>
  <li>name: string that identifies names</li>
  <li>surname: string that identifies surnames</li>
  <li>username: unique string that identifies usernames</li>
  <li>creationTime: autogenerated date when the user is created</li>
  <li>age: age of the user</li>
  <li>gender: gender of the user</li>
  <li>email: email string to use as username for authentication</li>
  <li>password: password of the user, hashed before sending it to db</li>
  <li>is_admin: boolean that identifies if the user is admin or not</li>
</ol>
We have two types of users, admins and basic users. Admins can execute all the methods, while basic users can only execute update and delete operations where they are the actors.
#### Get Users (admins and users)
Fetches all the users, the response body follows the UserOut schema.

#### Create User (admins only)
Creation of users, admin only operation, the request body follows the UserCreate schema. Checks if username or email are already taken, code 409 conflict

#### Get User (admins and users)
Gets the user by user_id. If the user does not exists, code 404: Not found.

#### Delete User (admins and users)
With the user_id, admins can delete all the users while users can only delete themselves. If the user doesn't exists, code 404: not found.

#### Update User (admins and users)
With the user_id, admins can update all the users while users can only update themselves. There's no need to update all the fields. Checks if the user exists or if the username is not taken.

### friendships
Friendships are unidirectional, it only has two fields, user_id and frend_id. This represents that user_id is friend of friend_id, but friend_id is not friend of user_id. I wanted to do it similar to some social networks like instagram or twitter, where you can add someone as friend without the other person adding you.

//TO DO
boolean is_reciprocal and join when getting or store both ways and create an index.

#### Create Friendships (admins and users)
With user_id and friend_id, admins can create any friendship, while users can only create relationships where they are the user_id. Checks if the users exist and if the relationship is already done.

#### Delete Friendships (admins and users)
With user_id and friend_id, admins can delete any existing relationship, while users can only delete relationships where they are the user_id. Checks if the current user is the user_id and if the relationship exists.

#### Get Friendships (admins and users)
With user_id, any user can search the friends of any user.
